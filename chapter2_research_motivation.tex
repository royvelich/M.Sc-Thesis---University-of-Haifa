\chapter{Research Motivation}

\section{Research Motivation}
Geometry processing is the hidden engine that propels many design tools used by the graphics-related industry. Shape deformation, remeshing, surface parameterization, texture synthesis and so forth \cite{PMP:2010} are some of the standard tasks within the geometry processing field. Geometry processing algorithms play key roles in the process of content creation, from the initial shaping of an object, through texturing and animation, to final analysis and further enhancements. Their purpose is to assist the artist in realizing a design that fits their vision, with the least effort possible. Yet, even with the most advanced algorithms, the design process is often long and tedious. It requires many trial-and-error iterations, tweaking and experimenting with parameters, improving and optimizing, until a desired result is achieved. Researchers are constantly attempting to improve the automation of the design process, to whatever extent possible, in order to ameliorate the burden of realizing a design. To do so, they attempt to deduce and predict potential objectives a designer might have, formulate optimization problems that represent those objectives, and compute optimal solutions for these representative problems. This approach is very appealing from a development perspective: the algorithm does not have to be efficient or have a user interface, since it is automatic. However, while automatic solutions may work in certain cases, in many other cases this approach is unhelpful, or even misguided. Designers often begin without a clearly defined objective and  decide, while exploring and experimenting with designs, when the result is satisfactory -- an ``\emph{I know it when I see it}" type of process. This phrase also serves to underline the difficulty inherent in the fact that some objectives are, in fact, \emph{subjective}.  Conversely, in some cases the designers \emph{do know} what they want, but the algorithm will continue suggesting a different design, because it better fits a set of preconceived objectives. This, obviously, leads to frustration and contradicts the very purpose that the tool was developed to accomplish: to aid the designer.

\noindent An alternative approach would be to develop systems for \emph{Guided Optimization}, where the user and the computer work together towards achieving the goal.

\noindent Guided optimization, also known as human-in-the-loop optimization, is possible when the algorithm manifests the three following properties:
\begin{enumerate}
\item It is responsive
\item It is predictable
\item It has an intuitive user interface
\end{enumerate}

\section{Guided Optimization}
\paragraph*{Responsiveness}
Responsiveness is the ability of an algorithm to react to input from the user in an interactive system. Normally, when developing a new optimization method, the aim is to converge to a minimum as quickly as possible. Iterative optimization processes require a certain number of iterations to converge, where each iteration requires a certain amount of time, thus reduction of the total time is the main goal. An important fact to consider is that optimizers cannot typically react to new input mid-step, so the duration of an iteration in a responsive algorithm should not be too long, i.e., the iterations should be \emph{efficient}. A rule of thumb is that 5-10 iterations per second is the minimal number that is still considered interactive. On the other hand, the optimizer should also be \emph{effective}, that is, each step should make sufficient, ideally clearly visible, progress. These two properties, efficiency and effectiveness, usually come at the expense of one another. The challenge in developing a guided optimization is to find or construct an algorithm that balances the two well. 

For example, two well-known methods for surface parameterization are the quasi-Newton method from \cite{Smith:2015}, and the second-order cone programming (SOCP) method from \cite{Lipman:2012}. A quasi-Newton step takes a fraction of the time that an SOCP step takes, but the quasi-Newton method usually requires thousands of iterations to converge, while the SOCP approach usually requires less than ten. Nevertheless, even though the total time the SOCP approach requires is generally shorter, it can not be used for guided optimization, since the duration of each individual iteration is too long. The quasi-Newton method cannot be used either, simply because it is not effective enough. In \cite{Poranne:Autocuts:2017}, we found that the composite majorization approach strikes the right balance for small sized meshes. Handling of large sized meshes is discussed in this proposal later.

\paragraph*{Predictability}
During the interaction with a guided-optimization system, it is very important that the effects of a certain action are predictable. The problems we solve are normally formulated with many constraints and have many local minima. A small variation in the input can easily cause the optimizer to fall unexpectedly into a local minimum, produce dramatic changes in the result, and ruin the design-in-progress. The problem is further exacerbated in the presence of discrete variables or objectives. These occurrences are extremely frustrating to a designer and can easily cause a simple project to become painstaking and time-consuming. My approach to avoiding this problem is to allow the constraints to be violated in a controllable manner. One way to do so is by utilizing the continuation method, as explained below.

\paragraph*{User interface}
A guided optimization system requires a user-friendly interface. A user interface in this context is more than just a graphics display with text boxes for parameters, but rather a mechanism that allows a user to trace curves, make gestures with the mouse, and express their wishes in a much more refined and subtle manner. The design of such interfaces is an arduous task, and unfortunately one that is not often discussed in scientific papers. A well-designed user interface has the potential to render a problem much more manageable, even without the use of powerful optimization, while a poorly-designed one can leave the user feeling frustrated and unsatisfied with the results, even though it may be running a powerful algorithm behind the scenes. The investigation and optimization of user interfaces is much less structured than other computational problems. In the following section, I will present a few relevant examples.

\section{Guided Optimization for Quad Remeshing}
Inspired by \cite{Poranne:Autocuts:2017}, which formulated the problem of UV mappings as a guided optimization problem, we make an attempt, in this work, to formulate the problem of \emph{Quad Remeshing} as a guided optimization problem.
Many applications in computer graphics, such as character modeling and animation, architectural geometry, and physical simulation to some extent, call for quad meshes as a representation of the geometry. However, since triangle meshes are generally more prevalent and are naturally the type of mesh generated by object acquisition and surface reconstruction methods, they need to be converted to a quad mesh via the process known as quad remeshing. In the following chapters, we give a brief overview of related works in the field of quad remeshing, and describe in detail our own approach and contribution for the solution of this problem.
